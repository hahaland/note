# TCP连接

## TCP首部格式
![alt text](/static/img/tcp_head.jpg "Title")

每一项占4个字节
- 源端口+目的端口：各2字节，16位
- 序号（seq）：当前报文的index，由于长度有限，到最大值后又会回到0，需要通过某种方法区分重复的序列号
- 确认号（ack）：下一次发送的报文的序号
- TCP首部长度+各标志位：
  
  TCP首部长度，即指明数据段位置
    标志位|作用
    -|-
    URG | 当前报文是否包含紧急数据，1为包含
    ACK | 确认号ack是否有效
    PSH | 接收端是否立即将数据提交上层，而不是在缓冲区中
    RST | =1时说明发送方请求重新建立连接（主机崩溃、数据有问题主机拒绝响应）
    SYN | 建立连接的flag，用于判断握手过程。请求建立连接时SYN=1、ACK=0；接受方收到后，同意建立连接则ACK=1
    FIN | 数据是否发送完毕，即是否完成传输任务、释放连接

## 三次握手
客户端a与服务端b建立连接，需要确认通信双方数据原点的序号，才是可靠的连接。

### 第一次握手 a -> b

a希望建立连接，所以SYN=1，由于未建立连接，ACK=0，seq为随机数x（SYN=1，ACK=0，seq=x）

*a告知自己初始的序号*

### 第二次握手 a <- b

b同意建立连接，seq为随机数y，希望下次对方的序列号ack为x+1，ACK=1，SYN=1

*b确认a的初始序号，并向a发送自己的序号*

### 第三次握手 a -> b

a需要告知b确认收到同意连接，seq=x+1，ack=y+1，ACK=1，SYN=0

*a保存b的序号，并告知b已确认，b收到即代表同步成功*

### 为什么需要三次握手
为了保证的是双方seq与ack的对应关系。

TCP的一个基本设计：
- 就是通过序列号seq区分不同的包
- 累加的确认机制，意味着序列号前面的包都被接收了

初始序列号由一个32位的时钟生成，大概每4.55个小时循环一次序列号，而报文在网络中存在的时间（MSL）一般默认2分钟（windows 2min；linux 60s；Unix 30s），所以可以认为初始序列号是唯一的。

由于发送方与接收方使用的时钟可能不一致，且双方都能发送数据（TCP是全双工），因此双方都需要对方的初始序列号。

如果连接出问题，接收方要通过seq区分新连接的包还是旧连接重发的包，就需要一个确认seq的过程。

## 四次挥手

与三次握手的区别是，当一方请求断开连接时，另一方可能还有剩余数据需要发送，不一定会断开，因此需要另一方单独发送关闭请求，每个请求两次挥手。

### 第一次挥手 a -> b

a停止发送数据，告知b关闭接收a数据的通道，FIN=1，seq与ack按建立连接规则计算。

### 第二次挥手 a <- b

b关闭接收a的通道，并向a发送确认关闭（此时b仍可发送数据给a），seq与ack按建立连接规则计算。

### b发送剩余数据

### 第三次挥手 a <- b

当b将剩余数据发送完后，告诉a关闭接收b通道，FIN=1，seq与ack按建立连接规则计算

### 第四次挥手 a -> b

a向b发送确认关闭，FIN=1， seq与ack按建立连接规则计算。此时a还未关闭TCP连接，需等待b没有在发送报文（即确认b收到此消息）后，才关闭连接，这段时间为一个来回的传输时间，即2MSL(MSL为最大报文寿命)。


# http协议

## 内容
客户端：
- 请求行： 包括请求方法（get、post、head、put、delete、option、trace、connet）、url字段、http协议版本（空格分隔。如，GET /index.html HTTP/1.1）
- 请求头：
  - User-Agent：发送方的浏览器类型；
  - Accept：客户端可识别的内容类型列表；
  - Host：主机名；
  - Referer：来源网页的地址，包括url参数（可以用于防盗链，不在名单内的网页不返回内容，有泄漏隐私的风险）
  - origin：由协议+域名+端口组成， 与referer相比，不包含参数，只有跨域请求会携带origin，用于跨域的白名单判断
- 空行：用来告诉对方请求头结束
- 请求正文： 用于存放POST请求的内容

服务器：

- 状态行：
  - HTTP协议版本、
  - Status-Code状态码
    | 状态码 | 含义|
    |:-|-:|
    |100 | 服务器已收到请求一部分，告诉客户端继续发送|
    |101|服务器已准备切换协议|
    |2xx|成功处理请求|
    |201|资源创建成功|
    |202|请求已接收但服务器未处理|
    |204|没有内容，单纯的告知成功状态|
    |3xx|重定向|
    |300|当前请求服务器有多个对应的操作，需要客户端选择|
    |301|请求的资源已经永久移动到其他位置，Response中会带上新的url|
    |302| 与301不同的是临时移动，请求的路径无需变化|
    |304|资源未修改，告知客户端使用缓存|
    |305|需要代理地址访问资源，地址在Response的Location中|
    |4xx|失败，客户端的错误|
    |400|错误的请求|
    |401|需要身份认证，一般用户需要登录状态的请求|
    |403|服务器拒绝请求|
    |404|找不到资源|
    |405|不支持请求方法|
    |408|服务器等待客户端时间过久，发送408关闭连接|
    |410|找不到资源，但曾经有过|
    |411|需要在Request中带上Content-length内容长度|
    |5xx|失败，服务器的错误|
    |500|服务器内部错误，无法为请求提供服务|
    |501|服务器不支持当前请求（未实现）|
    |502|网关故障|
    |503|服务器需要过段时间才能正常服务|
    |504|网关超时|
    |505|不支持请求的http协议版本|

  - Reason-Phrase状态码的文本描述
- 响应报头： 描述服务器的信息和数据的描述
- 正文

## 特点
- 属于应用层协议
- 无状态，每个请求都是相互独立的

## 无状态的解决方案
### cookie
  服务器通过在http响应头添加一行特殊的指示，浏览器根据指示生成对应的cookie，内容主要包括名字、值、过期时间、路径、域
  >缺点是大小受限，安全性低、会被禁用、有些状态不能保存在客户端

### 服务器的session机制

新建连接时，服务器会创造一个唯一的session id并保存在一个表里，通过cookie带给客户端，客户端每次请求带上id，服务器会判断是哪个会话，cookie被禁时id也能通过url参数传递。
> 缺点：由于是服务器处理，用户数量很多时服务器压力增大

### html5的webStorage
- sessionStorage
  数据在页面会话结束时会被清除（网页内打开的新页面才属于一个会话）
- localStorage
