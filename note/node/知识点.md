### 模块机制

**`exports` 和 `module.exports` 区别**

  `exports` 是 `module.exports`的引用
  ```javascript
    exports = { a:1 } // 不生效 改变了引用
    exports.a = 1 // 生效

  ```

**`require` 实现**

**`import` 和 `require` 区别**

- import 有两种情况使用：
  - 一种是webpack转译import：
    
    将import转换成__webpack_require，首次引入时包会存放在modules对象中，key就是模块路径，后续相同的引入都是使用缓存，这时和require表现一致，都是同步执行

  - 一种是浏览器支持的es module规范，底层引擎会根据import深度遍历，分析模块依赖树，再从子节点往上执行
  https://juejin.cn/post/7020247627618861093#heading-9
  
  使用方式：import的包通过script标签加载(需要注意，模块类型的script请求跨域情况下需要添加crossorigin="use-credentials"，才会带上cookie等信息)
  https://www.zhangxinxu.com/wordpress/2018/08/browser-native-es6-export-import-module/
  ```html
    <script type="module" crossorigin="use-credentials" src="//cdn.xxx.com/.../1.mjs"></script>
    // 在不支持的浏览器中，上面脚本会被忽略，可以通过nomodule属性兼容
    <script nomodule src="fallback.js"></script>
  ```
- require 导出的是值的拷贝（浅拷贝）

**循环引用的问题**

也是分两种情况：
- import：
  先执行b模块
  ```javascript
  //a.js
  console.log("before import b")
  import {b} from "./b"
  console.log("b is " + b)
  export let a = b+1;

  //b.js
  console.log("before import a")
  import {a} from "./a"
  console.log("a is " + a)
  export let b = a+1;
  ```
  由于执行import a时 
### EventEmitter
Node.js 中绝大多数模块都依赖于此模块，Net、HTTP、FS、Stream 等，除了这些系统模块比较知名的 Express、Koa 框架中也能看到 EventEmitter


大致实现：
- 一个对象存放事件队列，key值对应事件
- 只有一个事件时不使用数组
- on 方法根据key值添加事件
- emit触发时，copy对应事件队列快照，而不是真正的队列
  ```javascript
  let EventEmitter = require('events')
  let emitter = new EventEmitter()

  function f2() {
    console.log('2')
  }
  function f1() {
    console.log('1')
    // 仍会执行f2，下次emit时才会生效
    emitter.removeListener('test', f2)
  }
  emitter.on('test', f1)
  emitter.on('test', f2)


  emitter.emit('test') // 输出1 2
  emitter.emit('test') // 输出1
  ```

### node热更新
**如何在不重启node服务的情况下更新代码？**

先看下模块a引用模块b的步骤：
- 判断模块b是否有缓存
- 如果没有：
  - 添加 b 到`require.cache`中（其中 key 为模块 B 的全路径）
  - 添加 b 模块引用至父模块 a 的children数组中
- 如果存在，判断a的chidren是否有b的引用，没有则添加引用


要更新模块，就需要**切断所有对旧模块的引用**，才不会引起内存泄露，上面的例子中有两个引用：
- require.cache[b]
- require.cache[b].parent.children(即首次引入的模块a)

但还有个问题，**多个模块的引用**，比如模块a中引入了c，c又引入了b，这时c对b的引用并没有方法可以删除，还是会泄露，这种问题可以通过遍历require.cache解决

这就完了？×

**一些包的重复引入可能会导致循环引用**，比如lodash（https://zhuanlan.zhihu.com/p/461945753 参考），且大都无法预见，因此对不熟悉的代码最好不要采用热更新的方式。

参考：https://zhuanlan.zhihu.com/p/460359101

**webpack热更新机制**

- webpack将模块存放在`__webpack_module`对象中
- 使用自定义require方法，根据key值（文件名）在上面对象中找到对应模块
- node启动服务，负责静态文件的获取
- 文件修改时，通过websocket发送消息给客户端，客户端收到后获取对应文件
- 更新`__webpack_module`对象中的对应模块
 