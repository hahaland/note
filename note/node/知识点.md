### 模块机制
- `exports` 和 `module.exports` 区别
  `exports` 是 `module.exports`的引用
  ```javascript
    exports = { a:1 } // 不生效 改变了引用
    exports.a = 1 // 生效

  ```

### EventEmitter
Node.js 中绝大多数模块都依赖于此模块，Net、HTTP、FS、Stream 等，除了这些系统模块比较知名的 Express、Koa 框架中也能看到 EventEmitter


大致实现：
- 一个对象存放事件队列，key值对应事件
- 只有一个事件时不使用数组
- on 方法根据key值添加事件
- emit触发时，copy对应事件队列快照，而不是真正的队列
  ```javascript
  let EventEmitter = require('events')
  let emitter = new EventEmitter()

  function f2() {
    console.log('2')
  }
  function f1() {
    console.log('1')
    // 仍会执行f2，下次emit时才会生效
    emitter.removeListener('test', f2)
  }
  emitter.on('test', f1)
  emitter.on('test', f2)


  emitter.emit('test') // 输出1 2
  emitter.emit('test') // 输出1
  ```

### node热更新
**如何在不重启node服务的情况下更新代码？**

先看下模块a引用模块b的步骤：
- 判断模块b是否有缓存
- 如果没有：
  - 添加 b 到`require.cache`中（其中 key 为模块 B 的全路径）
  - 添加 b 模块引用至父模块 a 的children数组中
- 如果存在，判断a的chidren是否有b的引用，没有则添加引用


要更新模块，就需要**切断所有对旧模块的引用**，才不会引起内存泄露，上面的例子中有两个引用：
- require.cache[b]
- require.cache[b].parent.children(即首次引入的模块a)

但还有个问题，**多个模块的引用**，比如模块a中引入了c，c又引入了b，这时c对b的引用并没有方法可以删除，还是会泄露，这种问题可以通过遍历require.cache解决

这就完了？×

**一些包的重复引入可能会导致循环引用**，比如lodash（https://zhuanlan.zhihu.com/p/461945753 参考），且大都无法预见，因此对不熟悉的代码最好不要采用热更新的方式。

参考：https://zhuanlan.zhihu.com/p/460359101

**webpack热更新机制**

- webpack将模块存放在`__webpack_module`对象中
- 使用自定义require方法，根据key值（文件名）在上面对象中找到对应模块
- node启动服务，负责静态文件的获取
- 文件修改时，通过websocket发送消息给客户端，客户端收到后获取对应文件
- 更新`__webpack_module`对象中的对应模块
 