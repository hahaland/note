# TCP连接

## TCP首部格式
![alt text](/static/img/tcp_head.jpg "Title")

每一项占4个字节
- 源端口+目的端口：各2字节，16位
- 序号（seq）：当前报文的index，由于长度有限，到最大值后又会回到0，需要通过某种方法区分重复的序列号
- 确认号（ack）：下一次发送的报文的序号
- TCP首部长度+各标志位：
  
  TCP首部长度，即指明数据段位置
    标志位|作用
    -|-
    URG | 当前报文是否包含紧急数据，1为包含
    ACK | 确认号ack是否有效
    PSH | 接收端是否立即将数据提交上层，而不是在缓冲区中
    RST | =1时说明发送方请求重新建立连接（主机崩溃、数据有问题主机拒绝响应）
    SYN | 建立连接的flag，用于判断握手过程。请求建立连接时SYN=1、ACK=0；接受方收到后，同意建立连接则ACK=1
    FIN | 数据是否发送完毕，即是否完成传输任务、释放连接

## 三次握手
客户端a与服务端b建立连接，需要确认通信双方数据原点的序号，才是可靠的连接。

### 第一次握手 a -> b

a希望建立连接，所以SYN=1，由于未建立连接，ACK=0，seq为随机数x（SYN=1，ACK=0，seq=x）

*a告知自己初始的序号*

### 第二次握手 a <- b

b同意建立连接，seq为随机数y，希望下次对方的序列号ack为x+1，ACK=1，SYN=1

*b确认a的初始序号，并向a发送自己的序号*

### 第三次握手 a -> b

a需要告知b确认收到同意连接，seq=x+1，ack=y+1，ACK=1，SYN=0

*a保存b的序号，并告知b已确认，b收到即代表同步成功*

### 为什么需要三次握手
为了保证的是双方seq与ack的对应关系。

TCP的一个基本设计：
- 就是通过序列号seq区分不同的包
- 累加的确认机制，意味着序列号前面的包都被接收了

初始序列号由一个32位的时钟生成，大概每4.55个小时循环一次序列号，而报文在网络中存在的时间（MSL）一般默认2分钟（windows 2min；linux 60s；Unix 30s），所以可以认为初始序列号是唯一的。

由于发送方与接收方使用的时钟可能不一致，且双方都能发送数据（TCP是全双工），因此双方都需要对方的初始序列号。

如果连接出问题，接收方要通过seq区分新连接的包还是旧连接重发的包，就需要一个确认seq的过程。

## 四次挥手

与三次握手的区别是，当一方请求断开连接时，另一方可能还有剩余数据需要发送，不一定会断开，因此需要另一方单独发送关闭请求，每个请求两次挥手。

### 第一次挥手 a -> b

a停止发送数据，告知b关闭接收a数据的通道，FIN=1，seq与ack按建立连接规则计算。

### 第二次挥手 a <- b

b关闭接收a的通道，并向a发送确认关闭（此时b仍可发送数据给a），seq与ack按建立连接规则计算。

### b发送剩余数据

### 第三次挥手 a <- b

当b将剩余数据发送完后，告诉a关闭接收b通道，FIN=1，seq与ack按建立连接规则计算

### 第四次挥手 a -> b

a向b发送确认关闭，FIN=1， seq与ack按建立连接规则计算。此时a还未关闭TCP连接，需等待b没有在发送报文（即确认b收到此消息）后，才关闭连接，这段时间为一个来回的传输时间，即2MSL(MSL为最大报文寿命)。


# http协议

## 内容
客户端：
- 请求行： 包括请求方法（get、post、head、put、delete、option、trace、connet）、url字段、http协议版本（空格分隔。如，GET /index.html HTTP/1.1）

- 请求头：
  - User-Agent：发送方的浏览器类型；
  - Accept：客户端可识别的内容类型列表；
  - Host：主机名；
  - Referer：来源网页的地址，包括url参数（可以用于防盗链，不在名单内的网页不返回内容，有泄漏隐私的风险）
  - origin：由协议+域名+端口组成， 与referer相比，不包含参数，只有跨域请求会携带origin，用于跨域的白名单判断
- 空行：用来告诉对方请求头结束
- 请求正文： 用于存放POST请求的内容
> get和post的区别，get请求通过url，放在请求头中，因此会有大小限制，且可以缓存，post的参数放在正文中，资源不会被缓存

服务器：

- 状态行：
  - HTTP协议版本、
  - Status-Code状态码
    | 状态码 | 含义|
    |:-|-:|
    |100 | 服务器已收到请求一部分，告诉客户端继续发送|
    |101|服务器已准备切换协议|
    |2xx|成功处理请求|
    |201|资源创建成功|
    |202|请求已接收但服务器未处理|
    |204|没有内容，单纯的告知成功状态|
    |3xx|重定向|
    |300|当前请求服务器有多个对应的操作，需要客户端选择|
    |*301|请求的资源已经永久移动到其他位置，Response中会带上新的url|
    |*302| 与301不同的是临时移动，请求的路径无需变化|
    |*304|资源未修改，告知客户端使用缓存|
    |305|需要代理地址访问资源，地址在Response的Location中|
    |4xx|失败，客户端的错误|
    |*400|请求头不完整，一半是cookie过长导致|
    |*401|需要身份认证，一般用户需要登录状态的请求|
    |*403|服务器拒绝请求，没有权限访问|
    |404|找不到资源|
    |405|不支持请求方法|
    |408|服务器等待客户端时间过久，发送408关闭连接|
    |410|找不到资源，但曾经有过|
    |411|需要在Request中带上Content-length内容长度|
    |5xx|失败，服务器的错误|
    |*500|服务器内部错误，无法为请求提供服务|
    |501|服务器不支持当前请求（未实现）|
    |502|网关故障|
    |503|服务器需要过段时间才能正常服务|
    |504|网关超时|
    |505|不支持请求的http协议版本|

  - Reason-Phrase状态码的文本描述
- 响应报头： 描述服务器的信息和数据的描述
- 正文

## 特点
- 属于应用层协议
- 无状态，每个请求都是相互独立的
- http1.0是短连接，每次请求都会重新建立tcp连接
- http1.1默认使用长连接，响应头中会加入```Connection:keep-alive```，一次tcp连接可以进行多次请求来解决1.0单个请求的问题，但是会有队头阻塞的情况（前面的请求阻塞后，后面的处于等待状态）
## http请求/响应过程
1. 浏览器输入url回车
2. dns服务器解析url域名对应的ip地址
3. 根据url的端口或默认端口与服务器建立tcp连接
4. 服务器响应请求，回应浏览器
5. 断开tcp连接

## http2
旨在解决http1.x的性能问题，改进如下：
- 请求头的压缩
- server push(服务器推送)，请求一个资源时，服务器提前把相关资源一并发送，减少请求次数
- 多路复用，

## 无状态的解决方案
### cookie
  服务器通过在http响应头添加一行特殊的指示，浏览器根据指示生成对应的cookie，内容主要包括名字、值、过期时间、路径、域
  >缺点是大小受限，安全性低、会被禁用、有些状态不能保存在客户端

### 服务器的session机制

新建连接时，服务器会创造一个唯一的session id并保存在一个表里，通过cookie带给客户端，客户端每次请求带上id，服务器会判断是哪个会话，cookie被禁时id也能通过url参数传递。
> 缺点：由于是服务器处理，用户数量很多时服务器压力增大

### html5的webStorage
- sessionStorage
  数据在页面会话结束时会被清除（网页内打开的同样域名的新页面才属于一个会话）
- localStorage
  和session的区别是永久存在的

### html5的websocket

## 浏览器的缓存机制

### 强制缓存
- Expires： 一个GMT时间，客户端通过比对时间判断是否要使用缓存，但是客户端的时间可以随意修改导致缓存机制的不准确
- Cache-Control：返回的是相对过期的时间，比如返回10秒，则10秒内使用缓存，解决Expire的问题（有Cache-Control优先使用）
  > 值：max-age- xxx（时间）,public/private/immutable(客户端与服务器都缓存/服务器不缓存/即使刷新也使用缓存)| no-cache（无强制缓存） | no-store(无缓存，包括协商缓存)

### 协商缓存

协商缓存是在强制缓存到期后，与服务器通信判断是否需要更新缓存，优先级比强制低。
- Last-Modified和If-Modified-Since：
  Last-Modified，服务器返回的修改时间，当缓存过期时，浏览器在请求头带上If-Modified-Since（值为Last-Modified），如果一致则服务器返回304，不一致就重新发送内容和Last-Modified
  > 缺点：精确到秒，更短时间的修改无法判断；内容没有变化但修改时间变化了，有些服务器无法得到文件修改时间
- ETag和If-None-match： 通常是使用内容散列值，最后修改时间戳的哈希值，或者简单使用版本号，缓存过期后浏览器请求带上If-None-match（值为ETag和If），机制和last-modified一样。

