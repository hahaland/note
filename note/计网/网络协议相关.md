# TCP连接

## TCP首部格式
![alt text](/static/img/tcp_head.jpg "Title")

每一项占4个字节
- 源端口+目的端口：各2字节，16位
- 序号（seq）：当前报文的index，由于长度有限，到最大值后又会回到0，用来区分不同的tcp连接（因为连接不一定是连续的）
- 确认号（ack）：下一次发送的报文的序号
- TCP首部长度+各标志位：
  
  TCP首部长度，即指明数据段位置
    标志位|作用
    -|-
    URG | 当前报文是否包含紧急数据，1为包含
    ACK | 确认号ack是否有效（tcp规定建立连接后ack需要置为1）
    PSH | 接收端是否立即将数据提交上层，而不是在缓冲区中
    RST | =1时通知发送方tcp连接出现严重问题（主机崩溃、数据有问题主机拒绝响应），需要断开连接后重新建立连接
    SYN | 建立连接的flag，用于判断握手过程。请求建立连接时SYN=1、ACK=0；接受方收到后，同意建立连接则ACK=1
    FIN | 数据是否发送完毕，即是否完成传输任务、释放连接

## 三次握手
客户端a与服务端b建立连接，需要确认通信双方数据原点的序号，才是可靠的连接。

### 第一次握手 a -> b

a希望建立连接，所以SYN=1，由于未建立连接，ACK=0，seq为报文段序号 x（SYN=1，ACK=0，seq=x）

*a告知自己初始的序号*

### 第二次握手 a <- b

b同意建立连接，将相关信息放入半连接队列（SYN队列）seq为b的连接序号y，希望下次对方的序列号ack为x+1，ACK=1，SYN=1

*b确认a的初始序号，将信息放入半连接队列，并向a发送自己的序号*

### 第三次握手 a -> b

- a需要告知b确认收到同意连接，seq=x+1，ack=y+1，ACK=1，SYN=0
- b收到后，如果全连接队列没满，就从半连接将之前的信息取出放入全连接队列，如果满了根据tcp_abort_on_overflow配置执行策略

tcp_abort_on_overflow：
- 为0时，服务端会丢弃该包，重新从第二次握手开始，重试次数超过一定次数（tcp_synack_retries ，linux默认为5）则服务端返回RST，连接作废
- 为1时，服务端直接返回RST，连接作废
*a保存b的序号，并告知b已确认，b收到且放入全连接队列即代表同步成功*

### 为什么需要三次握手
为了保证的是双方seq与ack的对应关系。

TCP的一个基本设计：
- 就是通过序列号seq区分不同的包（初始序列号由一个32位的时钟生成，大概每4.55个小时循环一次序列号，而报文在网络中存在的时间（MSL）一般默认2分钟（windows 2min；linux 60s；Unix 30s），所以可以认为初始序列号是唯一的）
- 累加的确认机制，意味着序列号前面的包都被接收了
- 滑动窗口，为了提升信道利用率，会**一次发送多个包，通过确认号来确认收到数据的连续性**（比如初始序号10，一次性发送了20个，接收方收到前10个，这时前十个就不需要再次发送，接收方确认号变成21，告知发送方从序号21开始发送）

  tcp头部有个window字段，用来告知发送端窗口大小，一般使用所有设备中window最小的一个（木桶效应）

由于发送方与接收方使用的时钟可能不一致，且双方都能发送数据（TCP是全双工），因此双方都需要对方的初始序列号来建立双向的联系，这里就需要两次握手，第三次握手是为了确认前面的过程没问题。

如果连接出问题，接收方要通过seq区分新连接的包还是旧连接重发的包，就需要一个确认seq的过程。

### 常见的三次握手异常

**1、服务器端口不足导致等待时间过长**

服务器为了查找端口需要不断耗费cpu通过hash查找

解决：
- 增加端口数量
- 使用长连接以复用连接

**2、连接队列满导致握手异常 **

- 半连接队列满且tcp_syncookies=0，包会被直接舍弃
- 通过了半连接队列，但全连接队列满（第一次握手会丢包，第三次握手会重试一定次数）
## 四次挥手

与三次握手的区别是，当一方请求断开连接时，另一方可能还有剩余数据需要发送，不一定会断开，因此需要另一方单独发送关闭请求，每个请求两次挥手。

### 第一次挥手 a -> b

a停止发送数据，告知b关闭接收a数据的通道，FIN=1，seq与ack按建立连接规则计算。

### 第二次挥手 a <- b

b关闭接收a的通道，并向a发送确认关闭（此时b仍可发送数据给a），seq与ack按建立连接规则计算。

### b发送剩余数据

### 第三次挥手 a <- b

当b将剩余数据发送完后，告诉a关闭接收b通道，FIN=1，seq与ack按建立连接规则计算

### 第四次挥手 a -> b

a向b发送确认关闭，FIN=1， seq与ack按建立连接规则计算。此时a还未关闭TCP连接，需等待b没有在发送报文（即确认b收到此消息）后，才关闭连接，这段时间为一个来回的传输时间，即2MSL(MSL为最大报文寿命)。

### backlog参数

已连接但未进行accept处理的SOCKET队列大小，用来缓存socket未来得及处理的请求

### 粘包
默认情况下，tcp连接会启用延迟传送算法(Nagle)，将短时间内的数据合成一次发送，来减少I/O，如果数据之间没有关联，则需要做拆分处理，一般有三种方式：
- 消息之间间隔一段时间
- 关闭延迟算法

  `socket.setNoDelay()`方法可以关闭，一般用在发送数据较大，频率不高的场景，但网络差的情况下可能在客户端造成粘包
- 封包/拆包

  封装数据，添加一些标识，客户端之后对包进行处理  

https://coolshell.cn/articles/11609.html
# http协议

## 内容
客户端：
- 请求行： 包括请求方法（get、post、head、put、delete、option、trace、connet）、url字段、http协议版本（空格分隔。如，GET /index.html HTTP/1.1）

- 请求头：
  - User-Agent：发送方的浏览器类型；
  - Accept：客户端可识别的内容类型列表；
  - Host：主机名；
  - Referer：来源网页的地址，包括url参数（可以用于防盗链，不在名单内的网页不返回内容，有泄漏隐私的风险）
  - origin：由协议+域名+端口组成， 与referer相比，不包含参数，只有跨域请求会携带origin，用于跨域的白名单判断
- 空行：用来告诉对方请求头结束
- 请求正文： 用于存放POST请求的内容

服务器：

- 状态行：
  - HTTP协议版本、
  - Status-Code状态码
    | 状态码 | 含义|
    |:-|-:|
    |100 | 服务器已收到请求一部分，告诉客户端继续发送|
    |101|服务器已准备切换协议|
    |2xx|成功处理请求|
    |201|资源创建成功|
    |202|请求已接收但服务器未处理|
    |204|没有内容，单纯的告知成功状态|
    |3xx|重定向|
    |300|当前请求服务器有多个对应的操作，需要客户端选择|
    |*301|请求的资源已经永久移动到其他位置，Response中会带上新的url|
    |*302| 与301不同的是临时移动，请求的路径无需变化|
    |*304|资源未修改，告知客户端使用缓存|
    |305|需要代理地址访问资源，地址在Response的Location中|
    |4xx|失败，客户端的错误|
    |*400|请求头不完整，一半是cookie过长导致|
    |*401|需要身份认证，一般用户需要登录状态的请求|
    |*403|服务器拒绝请求，没有权限访问|
    |404|找不到资源|
    |405|不支持请求方法|
    |408|服务器等待客户端时间过久，发送408关闭连接|
    |410|找不到资源，但曾经有过|
    |411|需要在Request中带上Content-length内容长度|
    |5xx|失败，服务器的错误|
    |*500|服务器内部错误，无法为请求提供服务|
    |501|服务器不支持当前请求（未实现）|
    |502|网关故障|
    |503|服务器需要过段时间才能正常服务|
    |504|网关超时|
    |505|不支持请求的http协议版本|

  - Reason-Phrase状态码的文本描述
- 响应报头： 描述服务器的信息和数据的描述
- 正文

### GET和POST区别
- restful语义上，get应该用于获取数据，幂等（相同参数执行多次结果一样），post用于创建,不幂等，因此通常不缓存
- get请求通过url，放在请求头中，因此会有大小限制，且可以缓存，post除了能放url还能放在body中，
- get请求浏览器会自动缓存，post不会被缓存，除非手动设置
- 安全性上，post稍微比get好一点，参数不会再url中直接暴露，但http协议没有加密

当使用跨域、或者自定义header的请求时，会先发送一次option请求
## 特点
- 属于应用层协议
- 无状态，每个请求都是相互独立的
- http1.0是短连接，每次请求都会重新建立tcp连接
- http1.1默认使用长连接，响应头中会加入```Connection:keep-alive```，一次tcp连接可以进行多次请求来解决1.0单个请求的问题，但是会有队头阻塞的情况（前面的请求阻塞后，后面的处于等待状态）
## http请求/响应过程
1. 浏览器输入url回车
2. dns服务器解析url域名对应的ip地址
3. 根据url的端口或默认端口与服务器建立tcp连接
4. 服务器响应请求，回应浏览器
5. 断开tcp连接
## https协议

非对称加密（TLS握手）：
- 一组密钥a与b,a加密的结构可以用b解密，b加密的结果也可以用a解密
- 服务器保存一把复杂的钥匙作为私钥，比如b
- 当需要保密数据时，用a加密，私钥方用b解密
- 当需要向别人证明自己身份时，私钥方用b签名，即加密，外部用a解密

数据的传输需要加密，但非对称很耗时，因此https使用了采用混合加密：
- 服务器发送公钥
- 浏览器使用公钥加密对称密钥，传送给服务器
- 双方都能获得对称密钥
- 使用对称密钥传输后续的数据
- 对称秘钥

但这里有个问题，如何确保服务器和浏览器的公钥一致，这时就需要一个受信任的第三方机构验证公钥准确性：
- 首先，浏览器操作系统会预装机构证书，机构公钥可信
- 服务端向机构申请证书，机构通过私钥给证书明文hash签名，证书包含了网站信息、网站公钥、证书签名
- 服务端发送证书给浏览器，浏览器通过机构公钥解密签名，获得证书明文hash
- 浏览器使用证书指定的hash算法生成并与解密后的hash比较，由于伪造签名需要机构私钥，因此确保hash一致即可确保证书可信

因此，服务器需要先把公钥和网站信息给机构，申请证书，之后通过发送证书传送公钥，再继续之后的流程

但这样还有个问题，**对称秘钥是怎么生成的呢**？
- 客户端第一次请求时带上一个随机数
- 服务器返回证书、随机数、加密协议和算法
- 客户端验证证书通过后，再生成一个随机数，用证书公钥加密，返回给服务端
- 服务端和客户端之后各自使用这三个随机数生成相同的对称秘钥

**为什么需要随机数？**
为了保证对称秘钥的随机性，通过使用不同机器生成的三个随机数，保证了秘钥的随机性，且最后

https://zhuanlan.zhihu.com/p/43789231
## http2
旨在解决http1.x的性能问题，改进如下：
- 二进制帧，包含了帧的请求信息、内容，顺序，使其**可以乱序发送，且占用更小**，是多路复用的基础
- 请求头的压缩
- 客户端和服务端维护一份header的索引表，后续的传输只携带变化的字段以更新索引表，减少重复字段的传输
- server push(服务器推送)，请求一个资源时，服务器提前把相关资源一并发送，减少请求次数
- 多路复用，一个tcp链接可以同时发送多个http请求，每个二进制帧有对应的流标识，用以区分请求
- 服务端推送，客户端只发送一个请求，但服务端可以主动推送更多资源，相当于提前加载

缺点：
- 没有限制同时请求数，服务器压力上升
- 始终基于tcp协议，当滑动窗口中的一个数据包阻塞会影响整个tcp连接

## http3
为了解决http2的队头阻塞问题，基于udp的quic协议
- 由于tcp是有序传输，滑动窗口内的所有包收到后才允许继续传输，因此会阻塞，基于udp的无序传输解决了这个问题
- 封装了传输可靠性、拥塞控制、丢包检测等功能解决udp不可靠的特性
- 四层header
  - UdpHeader
  - Packet Header，实现了可靠的连接，报文丢失可以根据其中的Packer number重传
  - quic frame header，包含了有序流的标识，用以组装对应的数据流
  - http3 frame header 定义了HTTP Header、Body的格式，以及服务器推送、QPACK编解码流等功能
- 继承了tls加密


https://zhuanlan.zhihu.com/p/431672713
https://zhuanlan.zhihu.com/p/405387352
## 无状态的解决方案
### cookie
  服务器通过在http响应头添加一行特殊的指示，浏览器根据指示生成对应的cookie，内容主要包括名字、值、过期时间、路径、域
  >缺点是大小受限，安全性低、会被禁用、有些状态不能保存在客户端、无法跨域

### 服务器的session机制

新建连接时，服务器会创造一个唯一的session id并保存在一个表里，通过cookie带给客户端，客户端每次请求带上id，服务器会判断是哪个会话，cookie被禁时id也能通过url参数传递。
> 缺点：由于是服务器处理，用户数量很多时服务器压力增大

### html5的webStorage
- sessionStorage
  数据在页面会话结束时会被清除（网页内打开的同样域名的新页面才属于一个会话）
- localStorage
  和session的区别是永久存在的

### html5的websocket

## 浏览器的缓存机制

### 强制缓存
- Expires： 一个GMT时间，客户端通过比对时间判断是否要使用缓存，但是客户端的时间可以随意修改导致缓存机制的不准确
- Cache-Control：返回的是相对过期的时间，比如返回10秒，则10秒内使用缓存，解决Expire的问题（有Cache-Control优先使用）
  > 值：max-age- xxx（时间）,public/private/immutable(客户端与服务器都缓存/服务器不缓存/即使刷新也使用缓存)| no-cache（无强制缓存） | no-store(无缓存，包括协商缓存)

### 协商缓存

协商缓存是在强制缓存到期后，与服务器通信判断是否需要更新缓存，优先级比强制低。
- Last-Modified和If-Modified-Since：
  Last-Modified，服务器返回的修改时间，当缓存过期时，浏览器在请求头带上If-Modified-Since（值为Last-Modified），如果一致则服务器返回304，不一致就重新发送内容和Last-Modified
  > 缺点：精确到秒，更短时间的修改无法判断；内容没有变化但修改时间变化了，有些服务器无法得到文件修改时间
- ETag和If-None-match： 通常是使用内容散列值，最后修改时间戳的哈希值，或者简单使用版本号，缓存过期后浏览器请求带上If-None-match（值为ETag和If），机制和last-modified一样。


# UDP协议
UDP 速度快, 开销低, 不用封包/拆包允许丢一部分数据,**监控统计/日志数据上报/流媒体通信等场景**都可以用 UDP. 目前 Node.js 的项目中使用 UDP 比较流行的是 StatsD 监控服务
