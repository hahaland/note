# TCP连接

## TCP首部格式
![alt text](/static/img/tcp_head.jpg "Title")

每一项占4个字节
- 源端口+目的端口：各2字节，16位
- 序号（seq）：当前报文的index，由于长度有限，到最大值后又会回到0，需要通过某种方法区分重复的序列号
- 确认号（ack）：下一次发送的报文的序号
- TCP首部长度+各标志位：
  
  TCP首部长度，即指明数据段位置
    标志位|作用
    -|-
    URG | 当前报文是否包含紧急数据，1为包含
    ACK | 确认号ack是否有效
    PSH | 接收端是否立即将数据提交上层，而不是在缓冲区中
    RST | =1时说明发送方请求重新建立连接（主机崩溃、数据有问题主机拒绝响应）
    SYN | 建立连接的flag，用于判断握手过程。请求建立连接时SYN=1、ACK=0；接受方收到后，同意建立连接则ACK=1
    FIN | 数据是否发送完毕，即是否完成传输任务、释放连接

## 三次握手
客户端a与服务端b建立连接，需要确认通信双方数据原点的序号，才是可靠的连接。

### 第一次握手 a -> b

a希望建立连接，所以SYN=1，由于未建立连接，ACK=0，seq为随机数x（SYN=1，ACK=0，seq=x）

*a告知自己初始的序号*

### 第二次握手 a <- b

b同意建立连接，seq为随机数y，希望下次对方的序列号ack为x+1，ACK=1，SYN=1

*b确认a的初始序号，并向a发送自己的序号*

### 第三次握手 a -> b

a需要告知b确认收到同意连接，seq=x+1，ack=y+1，ACK=1，SYN=0

*a保存b的序号，并告知b已确认，b收到即代表同步成功*

### 为什么需要三次握手
为了保证的是双方seq与ack的对应关系。

TCP的一个基本设计：
- 就是通过序列号seq区分不同的包
- 累加的确认机制，意味着序列号前面的包都被接收了

初始序列号由一个32位的时钟生成，大概每4.55个小时循环一次序列号，而报文在网络中存在的时间（MSL）一般默认2分钟（windows 2min；linux 60s；Unix 30s），所以可以认为初始序列号是唯一的。

由于发送方与接收方使用的时钟可能不一致，且双方都能发送数据（TCP是全双工），因此双方都需要对方的初始序列号。

如果连接出问题，接收方要通过seq区分新连接的包还是旧连接重发的包，就需要一个确认seq的过程。

## 四次挥手

与三次握手的区别是，当一方请求断开连接时，另一方可能还有剩余数据需要发送，不一定会断开，因此需要另一方单独发送关闭请求，每个请求两次挥手。

### 第一次挥手 a -> b

a停止发送数据，告知b关闭接收a数据的通道，FIN=1，seq与ack按建立连接规则计算。

### 第二次挥手 a <- b

b关闭接收a的通道，并向a发送确认关闭（此时b仍可发送数据给a），seq与ack按建立连接规则计算。

### b发送剩余数据

### 第三次挥手 a <- b

当b将剩余数据发送完后，告诉a关闭接收b通道，FIN=1，seq与ack按建立连接规则计算

### 第四次挥手 a -> b

a向b发送确认关闭，FIN=1， seq与ack按建立连接规则计算。此时a还未关闭TCP连接，需等待b没有在发送报文（即确认b收到此消息）后，才关闭连接，这段时间为一个来回的传输时间，即2MSL(MSL为最大报文寿命)。

